/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("nipplejs", [], factory);
	else if(typeof exports === 'object')
		exports["nipplejs"] = factory();
	else
		root["nipplejs"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../meta3d-utils/src/LandscapeUtils.js":
/*!*********************************************!*\
  !*** ../meta3d-utils/src/LandscapeUtils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBoundingClientRect: () => (/* binding */ getBoundingClientRect),\n/* harmony export */   getPageX: () => (/* binding */ getPageX),\n/* harmony export */   getPageY: () => (/* binding */ getPageY),\n/* harmony export */   getRootDom: () => (/* binding */ getRootDom),\n/* harmony export */   getScrollLeft: () => (/* binding */ getScrollLeft),\n/* harmony export */   getScrollTop: () => (/* binding */ getScrollTop),\n/* harmony export */   restoreDom: () => (/* binding */ restoreDom),\n/* harmony export */   rotateDom: () => (/* binding */ rotateDom)\n/* harmony export */ });\n/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./View */ \"../meta3d-utils/src/View.js\");\n\nlet rotateDom = targetDom => {\n  let width = (0,_View__WEBPACK_IMPORTED_MODULE_0__.getActualWidth)();\n  let height = (0,_View__WEBPACK_IMPORTED_MODULE_0__.getActualHeight)();\n  targetDom.style.position = 'absolute';\n  targetDom.style.width = `${height}px`;\n  targetDom.style.height = `${width}px`;\n  targetDom.style.left = `${0 - (height - width) / 2}px`;\n  targetDom.style.top = `${(height - width) / 2}px`;\n  targetDom.style.transform = 'rotate(90deg)';\n  targetDom.style.transformOrigin = '50% 50%';\n};\nlet restoreDom = targetDom => {\n  targetDom.style.position = 'absolute';\n  targetDom.style.width = `100%`;\n  targetDom.style.height = `100%`;\n  targetDom.style.left = `${0}px`;\n  targetDom.style.top = `${0}px`;\n  targetDom.style.transform = 'none';\n  targetDom.style.transformOrigin = '50% 50%';\n};\nlet getRootDom = () => {\n  return document.querySelector(\"#root\");\n};\nlet getPageX = ({\n  pageX,\n  pageY\n}) => {\n  if ((0,_View__WEBPACK_IMPORTED_MODULE_0__.isNeedHandleLandscape)()) {\n    return pageY;\n  }\n  return pageX;\n};\nlet getPageY = ({\n  pageX,\n  pageY\n}) => {\n  if ((0,_View__WEBPACK_IMPORTED_MODULE_0__.isNeedHandleLandscape)()) {\n    return (0,_View__WEBPACK_IMPORTED_MODULE_0__.getActualWidth)() - pageX;\n  }\n  return pageY;\n};\n// export let getMovementX = ({ movementX, movementY }) => {\n// \tif (isNeedHandleLandscape()) {\n// \t\treturn movementY\n// \t}\n// \treturn movementX\n// }\n// export let getMovementY = ({ movementX, movementY }) => {\n// \tif (isNeedHandleLandscape()) {\n// \t\t// return -movementX\n// \t\treturn movementX\n// \t}\n// \treturn movementY\n// }\nlet getScrollLeft = (scrollLeft, scrollTop) => {\n  if ((0,_View__WEBPACK_IMPORTED_MODULE_0__.isNeedHandleLandscape)()) {\n    return scrollTop;\n  }\n  return scrollLeft;\n};\nlet getScrollTop = (scrollLeft, scrollTop) => {\n  if ((0,_View__WEBPACK_IMPORTED_MODULE_0__.isNeedHandleLandscape)()) {\n    return (0,_View__WEBPACK_IMPORTED_MODULE_0__.getActualWidth)() - scrollLeft;\n  }\n  return scrollTop;\n};\nlet getBoundingClientRect = boundingClientRect => {\n  if ((0,_View__WEBPACK_IMPORTED_MODULE_0__.isNeedHandleLandscape)()) {\n    let top = (0,_View__WEBPACK_IMPORTED_MODULE_0__.getActualWidth)() - boundingClientRect.left - boundingClientRect.width;\n    let left = boundingClientRect.top;\n    let width = boundingClientRect.height;\n    let height = boundingClientRect.width;\n    return {\n      top,\n      left,\n      right: boundingClientRect.bottom,\n      bottom: boundingClientRect.right,\n      x: left,\n      y: top,\n      width,\n      height\n    };\n  }\n  return boundingClientRect;\n};\n\n//# sourceURL=webpack://nipplejs/../meta3d-utils/src/LandscapeUtils.js?\n}");

/***/ }),

/***/ "../meta3d-utils/src/View.js":
/*!***********************************!*\
  !*** ../meta3d-utils/src/View.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActualHeight: () => (/* binding */ getActualHeight),\n/* harmony export */   getActualWidth: () => (/* binding */ getActualWidth),\n/* harmony export */   getHeight: () => (/* binding */ getHeight),\n/* harmony export */   getWidth: () => (/* binding */ getWidth),\n/* harmony export */   isNeedHandleLandscape: () => (/* binding */ isNeedHandleLandscape)\n/* harmony export */ });\nlet getActualWidth = () => {\n  // return document.documentElement.clientWidth\n  return window.innerWidth || document.documentElement.clientWidth;\n};\nlet getActualHeight = () => {\n  // return document.documentElement.clientHeight\n  return window.innerHeight || document.documentElement.clientHeight;\n};\nlet isNeedHandleLandscape = () => {\n  return getActualWidth() <= getActualHeight();\n};\nlet getWidth = () => {\n  return isNeedHandleLandscape() ? getActualHeight() : getActualWidth();\n};\nlet getHeight = () => {\n  return isNeedHandleLandscape() ? getActualWidth() : getActualHeight();\n};\n\n//# sourceURL=webpack://nipplejs/../meta3d-utils/src/View.js?\n}");

/***/ }),

/***/ "./src/collection.js":
/*!***************************!*\
  !*** ./src/collection.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _nipple__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nipple */ \"./src/nipple.js\");\n/* harmony import */ var _super__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./super */ \"./src/super.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! meta3d-utils/src/LandscapeUtils */ \"../meta3d-utils/src/LandscapeUtils.js\");\n\n\n\n\n\n///////////////////////////\n///   THE COLLECTION    ///\n///////////////////////////\n\nfunction Collection(manager, options) {\n  var self = this;\n  self.nipples = [];\n  self.idles = [];\n  self.actives = [];\n  self.ids = [];\n  self.pressureIntervals = {};\n  self.manager = manager;\n  self.id = Collection.id;\n  Collection.id += 1;\n\n  // Defaults\n  self.defaults = {\n    zone: document.body,\n    multitouch: false,\n    maxNumberOfNipples: 10,\n    mode: 'dynamic',\n    position: {\n      top: 0,\n      left: 0\n    },\n    catchDistance: 200,\n    size: 100,\n    threshold: 0.1,\n    color: 'white',\n    fadeTime: 250,\n    dataOnly: false,\n    restJoystick: true,\n    restOpacity: 0.5,\n    lockX: false,\n    lockY: false,\n    shape: 'circle',\n    dynamicPage: false,\n    follow: false\n  };\n  self.config(options);\n\n  // Overwrites\n  if (self.options.mode === 'static' || self.options.mode === 'semi') {\n    self.options.multitouch = false;\n  }\n  if (!self.options.multitouch) {\n    self.options.maxNumberOfNipples = 1;\n  }\n  const computedStyle = getComputedStyle(self.options.zone.parentElement);\n  if (computedStyle && computedStyle.display === 'flex') {\n    self.parentIsFlex = true;\n  }\n  self.updateBox();\n  self.prepareNipples();\n  self.bindings();\n  self.begin();\n  return self.nipples;\n}\nCollection.prototype = new _super__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nCollection.constructor = Collection;\nCollection.id = 0;\nCollection.prototype.prepareNipples = function () {\n  var self = this;\n  var nips = self.nipples;\n\n  // Public API Preparation.\n  nips.on = self.on.bind(self);\n  nips.off = self.off.bind(self);\n  nips.options = self.options;\n  nips.destroy = self.destroy.bind(self);\n  nips.ids = self.ids;\n  nips.id = self.id;\n  nips.processOnMove = self.processOnMove.bind(self);\n  nips.processOnEnd = self.processOnEnd.bind(self);\n  nips.get = function (id) {\n    if (id === undefined) {\n      return nips[0];\n    }\n    for (var i = 0, max = nips.length; i < max; i += 1) {\n      if (nips[i].identifier === id) {\n        return nips[i];\n      }\n    }\n    return false;\n  };\n};\nCollection.prototype.bindings = function () {\n  var self = this;\n  // Touch start event.\n  self.bindEvt(self.options.zone, 'start');\n  // Avoid native touch actions (scroll, zoom etc...) on the zone.\n  self.options.zone.style.touchAction = 'none';\n  self.options.zone.style.msTouchAction = 'none';\n};\nCollection.prototype.begin = function () {\n  var self = this;\n  var opts = self.options;\n\n  // We place our static nipple\n  // if needed.\n  if (opts.mode === 'static') {\n    var nipple = self.createNipple(opts.position, self.manager.getIdentifier());\n    // Add it to the dom.\n    nipple.add();\n    // Store it in idles.\n    self.idles.push(nipple);\n  }\n};\n\n// Nipple Factory\nCollection.prototype.createNipple = function (position, identifier) {\n  var self = this;\n  var scroll = self.manager.scroll;\n  var toPutOn = {};\n  var opts = self.options;\n  var offset = {\n    x: self.parentIsFlex ? scroll.x : scroll.x + self.box.left,\n    y: self.parentIsFlex ? scroll.y : scroll.y + self.box.top\n  };\n  if (position.x && position.y) {\n    toPutOn = {\n      x: position.x - offset.x,\n      y: position.y - offset.y\n    };\n  } else if (position.top || position.right || position.bottom || position.left) {\n    // We need to compute the position X / Y of the joystick.\n    var dumb = document.createElement('DIV');\n    dumb.style.display = 'hidden';\n    dumb.style.top = position.top;\n    dumb.style.right = position.right;\n    dumb.style.bottom = position.bottom;\n    dumb.style.left = position.left;\n    dumb.style.position = 'absolute';\n    opts.zone.appendChild(dumb);\n\n    /*!edit by meta3d */\n    // var dumbBox = dumb.getBoundingClientRect();\n    var dumbBox = meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_3__.getBoundingClientRect(dumb.getBoundingClientRect());\n    opts.zone.removeChild(dumb);\n    toPutOn = position;\n    position = {\n      x: dumbBox.left + scroll.x,\n      y: dumbBox.top + scroll.y\n    };\n  }\n  var nipple = new _nipple__WEBPACK_IMPORTED_MODULE_0__[\"default\"](self, {\n    color: opts.color,\n    size: opts.size,\n    threshold: opts.threshold,\n    fadeTime: opts.fadeTime,\n    dataOnly: opts.dataOnly,\n    restJoystick: opts.restJoystick,\n    restOpacity: opts.restOpacity,\n    mode: opts.mode,\n    identifier: identifier,\n    position: position,\n    zone: opts.zone,\n    frontPosition: {\n      x: 0,\n      y: 0\n    },\n    shape: opts.shape\n  });\n  if (!opts.dataOnly) {\n    _utils__WEBPACK_IMPORTED_MODULE_2__.applyPosition(nipple.ui.el, toPutOn);\n    _utils__WEBPACK_IMPORTED_MODULE_2__.applyPosition(nipple.ui.front, nipple.frontPosition);\n  }\n  self.nipples.push(nipple);\n  self.trigger('added ' + nipple.identifier + ':added', nipple);\n  self.manager.trigger('added ' + nipple.identifier + ':added', nipple);\n  self.bindNipple(nipple);\n  return nipple;\n};\nCollection.prototype.updateBox = function () {\n  var self = this;\n\n  /*!edit by meta3d */\n  // self.box = self.options.zone.getBoundingClientRect();\n  self.box = meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_3__.getBoundingClientRect(self.options.zone.getBoundingClientRect());\n};\nCollection.prototype.bindNipple = function (nipple) {\n  var self = this;\n  var type;\n  // Bubble up identified events.\n  var handler = function (evt, data) {\n    // Identify the event type with the nipple's id.\n    type = evt.type + ' ' + data.id + ':' + evt.type;\n    self.trigger(type, data);\n  };\n\n  // When it gets destroyed.\n  nipple.on('destroyed', self.onDestroyed.bind(self));\n\n  // Other events that will get bubbled up.\n  nipple.on('shown hidden rested dir plain', handler);\n  nipple.on('dir:up dir:right dir:down dir:left', handler);\n  nipple.on('plain:up plain:right plain:down plain:left', handler);\n};\nCollection.prototype.pressureFn = function (touch, nipple, identifier) {\n  var self = this;\n  var previousPressure = 0;\n  clearInterval(self.pressureIntervals[identifier]);\n  // Create an interval that will read the pressure every 100ms\n  self.pressureIntervals[identifier] = setInterval(function () {\n    var pressure = touch.force || touch.pressure || touch.webkitForce || 0;\n    if (pressure !== previousPressure) {\n      nipple.trigger('pressure', pressure);\n      self.trigger('pressure ' + nipple.identifier + ':pressure', pressure);\n      previousPressure = pressure;\n    }\n  }.bind(self), 100);\n};\nCollection.prototype.onstart = function (evt) {\n  var self = this;\n  var opts = self.options;\n  var origEvt = evt;\n  evt = _utils__WEBPACK_IMPORTED_MODULE_2__.prepareEvent(evt);\n\n  // Update the box position\n  self.updateBox();\n  var process = function (touch) {\n    // If we can create new nipples\n    // meaning we don't have more active nipples than we should.\n    if (self.actives.length < opts.maxNumberOfNipples) {\n      self.processOnStart(touch);\n    } else if (origEvt.type.match(/^touch/)) {\n      // zombies occur when end event is not received on Safari\n      // first touch removed before second touch, we need to catch up...\n      // so remove where touches in manager that no longer exist\n      Object.keys(self.manager.ids).forEach(function (k) {\n        if (Object.values(origEvt.touches).findIndex(function (t) {\n          return t.identifier === k;\n        }) < 0) {\n          // manager has id that doesn't exist in touches\n          var e = [evt[0]];\n          e.identifier = k;\n          self.processOnEnd(e);\n        }\n      });\n      if (self.actives.length < opts.maxNumberOfNipples) {\n        self.processOnStart(touch);\n      }\n    }\n  };\n  _utils__WEBPACK_IMPORTED_MODULE_2__.map(evt, process);\n\n  // We ask upstream to bind the document\n  // on 'move' and 'end'\n  self.manager.bindDocument();\n  return false;\n};\nCollection.prototype.processOnStart = function (evt) {\n  var self = this;\n  var opts = self.options;\n  var indexInIdles;\n  var identifier = self.manager.getIdentifier(evt);\n  var pressure = evt.force || evt.pressure || evt.webkitForce || 0;\n\n  /*!edit by meta3d */\n  // var position = {\n  //     x: evt.pageX,\n  //     y: evt.pageY\n  // };\n  var position = {\n    x: meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_3__.getPageX(evt),\n    y: meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_3__.getPageY(evt)\n  };\n  var nipple = self.getOrCreate(identifier, position);\n\n  // Update its touch identifier\n  if (nipple.identifier !== identifier) {\n    self.manager.removeIdentifier(nipple.identifier);\n  }\n  nipple.identifier = identifier;\n  var process = function (nip) {\n    // Trigger the start.\n    nip.trigger('start', nip);\n    self.trigger('start ' + nip.id + ':start', nip);\n    nip.show();\n    if (pressure > 0) {\n      self.pressureFn(evt, nip, nip.identifier);\n    }\n    // Trigger the first move event.\n    self.processOnMove(evt);\n  };\n\n  // Transfer it from idles to actives.\n  if ((indexInIdles = self.idles.indexOf(nipple)) >= 0) {\n    self.idles.splice(indexInIdles, 1);\n  }\n\n  // Store the nipple in the actives array\n  self.actives.push(nipple);\n  self.ids.push(nipple.identifier);\n  if (opts.mode !== 'semi') {\n    process(nipple);\n  } else {\n    // In semi we check the distance of the touch\n    // to decide if we have to reset the nipple\n    var distance = _utils__WEBPACK_IMPORTED_MODULE_2__.distance(position, nipple.position);\n    if (distance <= opts.catchDistance) {\n      process(nipple);\n    } else {\n      nipple.destroy();\n      self.processOnStart(evt);\n      return;\n    }\n  }\n  return nipple;\n};\nCollection.prototype.getOrCreate = function (identifier, position) {\n  var self = this;\n  var opts = self.options;\n  var nipple;\n\n  // If we're in static or semi, we might already have an active.\n  if (/(semi|static)/.test(opts.mode)) {\n    // Get the active one.\n    // TODO: Multi-touche for semi and static will start here.\n    // Return the nearest one.\n    nipple = self.idles[0];\n    if (nipple) {\n      self.idles.splice(0, 1);\n      return nipple;\n    }\n    if (opts.mode === 'semi') {\n      // If we're in semi mode, we need to create one.\n      return self.createNipple(position, identifier);\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Coudln\\'t find the needed nipple.');\n    return false;\n  }\n  // In dynamic, we create a new one.\n  nipple = self.createNipple(position, identifier);\n  return nipple;\n};\nCollection.prototype.processOnMove = function (evt) {\n  var self = this;\n  var opts = self.options;\n  var identifier = self.manager.getIdentifier(evt);\n  var nipple = self.nipples.get(identifier);\n  var scroll = self.manager.scroll;\n\n  // If we're moving without pressing\n  // it's that we went out the active zone\n  if (!_utils__WEBPACK_IMPORTED_MODULE_2__.isPressed(evt)) {\n    this.processOnEnd(evt);\n    return;\n  }\n  if (!nipple) {\n    // This is here just for safety.\n    // It shouldn't happen.\n    // eslint-disable-next-line no-console\n    console.error('Found zombie joystick with ID ' + identifier);\n    self.manager.removeIdentifier(identifier);\n    return;\n  }\n  if (opts.dynamicPage) {\n    /*!edit by meta3d */\n    // var elBox = nipple.el.getBoundingClientRect();\n    var elBox = meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_3__.getBoundingClientRect(nipple.el.getBoundingClientRect());\n    nipple.position = {\n      x: scroll.x + elBox.left,\n      y: scroll.y + elBox.top\n    };\n  }\n  nipple.identifier = identifier;\n  var size = nipple.options.size / 2;\n\n  /*!edit by meta3d */\n  // var pos = {\n  //     x: evt.pageX,\n  //     y: evt.pageY\n  // };\n  var pos = {\n    x: meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_3__.getPageX(evt),\n    y: meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_3__.getPageY(evt)\n  };\n  if (opts.lockX) {\n    pos.y = nipple.position.y;\n  }\n  if (opts.lockY) {\n    pos.x = nipple.position.x;\n  }\n  var dist = _utils__WEBPACK_IMPORTED_MODULE_2__.distance(pos, nipple.position);\n  var angle = _utils__WEBPACK_IMPORTED_MODULE_2__.angle(pos, nipple.position);\n  var rAngle = _utils__WEBPACK_IMPORTED_MODULE_2__.radians(angle);\n  var force = dist / size;\n  var raw = {\n    distance: dist,\n    position: pos\n  };\n\n  // Clamp the position\n  var clamped_dist;\n  var clamped_pos;\n  if (nipple.options.shape === 'circle') {\n    // Clamp to a circle\n    clamped_dist = Math.min(dist, size);\n    clamped_pos = _utils__WEBPACK_IMPORTED_MODULE_2__.findCoord(nipple.position, clamped_dist, angle);\n  } else {\n    // Clamp to a square\n    clamped_pos = _utils__WEBPACK_IMPORTED_MODULE_2__.clamp(pos, nipple.position, size);\n    clamped_dist = _utils__WEBPACK_IMPORTED_MODULE_2__.distance(clamped_pos, nipple.position);\n  }\n  if (opts.follow) {\n    // follow behaviour\n    if (dist > size) {\n      let delta_x = pos.x - clamped_pos.x;\n      let delta_y = pos.y - clamped_pos.y;\n      nipple.position.x += delta_x;\n      nipple.position.y += delta_y;\n      nipple.el.style.top = nipple.position.y - (self.box.top + scroll.y) + 'px';\n      nipple.el.style.left = nipple.position.x - (self.box.left + scroll.x) + 'px';\n      dist = _utils__WEBPACK_IMPORTED_MODULE_2__.distance(pos, nipple.position);\n    }\n  } else {\n    // clamp behaviour\n    pos = clamped_pos;\n    dist = clamped_dist;\n  }\n  var xPosition = pos.x - nipple.position.x;\n  var yPosition = pos.y - nipple.position.y;\n  nipple.frontPosition = {\n    x: xPosition,\n    y: yPosition\n  };\n  if (!opts.dataOnly) {\n    nipple.ui.front.style.transform = 'translate(' + xPosition + 'px,' + yPosition + 'px)';\n  }\n\n  // Prepare event's datas.\n  var toSend = {\n    identifier: nipple.identifier,\n    position: pos,\n    force: force,\n    pressure: evt.force || evt.pressure || evt.webkitForce || 0,\n    distance: dist,\n    angle: {\n      radian: rAngle,\n      degree: angle\n    },\n    vector: {\n      x: xPosition / size,\n      y: -yPosition / size\n    },\n    raw: raw,\n    instance: nipple,\n    lockX: opts.lockX,\n    lockY: opts.lockY\n  };\n\n  // Compute the direction's datas.\n  toSend = nipple.computeDirection(toSend);\n\n  // Offset angles to follow units circle.\n  toSend.angle = {\n    radian: _utils__WEBPACK_IMPORTED_MODULE_2__.radians(180 - angle),\n    degree: 180 - angle\n  };\n\n  // Send everything to everyone.\n  nipple.trigger('move', toSend);\n  self.trigger('move ' + nipple.id + ':move', toSend);\n};\nCollection.prototype.processOnEnd = function (evt) {\n  var self = this;\n  var opts = self.options;\n  var identifier = self.manager.getIdentifier(evt);\n  var nipple = self.nipples.get(identifier);\n  var removedIdentifier = self.manager.removeIdentifier(nipple.identifier);\n  if (!nipple) {\n    return;\n  }\n  if (!opts.dataOnly) {\n    nipple.hide(function () {\n      if (opts.mode === 'dynamic') {\n        nipple.trigger('removed', nipple);\n        self.trigger('removed ' + nipple.id + ':removed', nipple);\n        self.manager.trigger('removed ' + nipple.id + ':removed', nipple);\n        nipple.destroy();\n      }\n    });\n  }\n\n  // Clear the pressure interval reader\n  clearInterval(self.pressureIntervals[nipple.identifier]);\n\n  // Reset the direciton of the nipple, to be able to trigger a new direction\n  // on start.\n  nipple.resetDirection();\n  nipple.trigger('end', nipple);\n  self.trigger('end ' + nipple.id + ':end', nipple);\n\n  // Remove identifier from our bank.\n  if (self.ids.indexOf(nipple.identifier) >= 0) {\n    self.ids.splice(self.ids.indexOf(nipple.identifier), 1);\n  }\n\n  // Clean our actives array.\n  if (self.actives.indexOf(nipple) >= 0) {\n    self.actives.splice(self.actives.indexOf(nipple), 1);\n  }\n  if (/(semi|static)/.test(opts.mode)) {\n    // Transfer nipple from actives to idles\n    // if we're in semi or static mode.\n    self.idles.push(nipple);\n  } else if (self.nipples.indexOf(nipple) >= 0) {\n    // Only if we're not in semi or static mode\n    // we can remove the instance.\n    self.nipples.splice(self.nipples.indexOf(nipple), 1);\n  }\n\n  // We unbind move and end.\n  self.manager.unbindDocument();\n\n  // We add back the identifier of the idle nipple;\n  if (/(semi|static)/.test(opts.mode)) {\n    self.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;\n  }\n};\n\n// Remove destroyed nipple from the lists\nCollection.prototype.onDestroyed = function (evt, nipple) {\n  var self = this;\n  if (self.nipples.indexOf(nipple) >= 0) {\n    self.nipples.splice(self.nipples.indexOf(nipple), 1);\n  }\n  if (self.actives.indexOf(nipple) >= 0) {\n    self.actives.splice(self.actives.indexOf(nipple), 1);\n  }\n  if (self.idles.indexOf(nipple) >= 0) {\n    self.idles.splice(self.idles.indexOf(nipple), 1);\n  }\n  if (self.ids.indexOf(nipple.identifier) >= 0) {\n    self.ids.splice(self.ids.indexOf(nipple.identifier), 1);\n  }\n\n  // Remove the identifier from our bank\n  self.manager.removeIdentifier(nipple.identifier);\n\n  // We unbind move and end.\n  self.manager.unbindDocument();\n};\n\n// Cleanly destroy the manager\nCollection.prototype.destroy = function () {\n  var self = this;\n  self.unbindEvt(self.options.zone, 'start');\n\n  // Destroy nipples.\n  self.nipples.forEach(function (nipple) {\n    nipple.destroy();\n  });\n\n  // Clean 3DTouch intervals.\n  for (var i in self.pressureIntervals) {\n    if (self.pressureIntervals.hasOwnProperty(i)) {\n      clearInterval(self.pressureIntervals[i]);\n    }\n  }\n\n  // Notify the manager passing the instance\n  self.trigger('destroyed', self.nipples);\n  // We unbind move and end.\n  self.manager.unbindDocument();\n  // Unbind everything.\n  self.off();\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Collection);\n\n//# sourceURL=webpack://nipplejs/./src/collection.js?\n}");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./manager */ \"./src/manager.js\");\n\nconst factory = new _manager__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  create: function (options) {\n    return factory.create(options);\n  },\n  factory: factory\n});\n\n//# sourceURL=webpack://nipplejs/./src/index.js?\n}");

/***/ }),

/***/ "./src/manager.js":
/*!************************!*\
  !*** ./src/manager.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collection */ \"./src/collection.js\");\n/* harmony import */ var _super__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./super */ \"./src/super.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n\n\n///////////////////////\n///     MANAGER     ///\n///////////////////////\n\nfunction Manager(options) {\n  var self = this;\n  self.ids = {};\n  self.index = 0;\n  self.collections = [];\n  self.scroll = _utils__WEBPACK_IMPORTED_MODULE_2__.getScroll();\n  self.config(options);\n  self.prepareCollections();\n\n  // Listen for resize, to reposition every joysticks\n  var resizeHandler = function () {\n    var pos;\n    self.collections.forEach(function (collection) {\n      collection.forEach(function (nipple) {\n        pos = nipple.el.getBoundingClientRect();\n        nipple.position = {\n          x: self.scroll.x + pos.left,\n          y: self.scroll.y + pos.top\n        };\n      });\n    });\n  };\n  _utils__WEBPACK_IMPORTED_MODULE_2__.bindEvt(window, 'resize', function () {\n    _utils__WEBPACK_IMPORTED_MODULE_2__.throttle(resizeHandler);\n  });\n\n  // Listen for scrolls, so we have a global scroll value\n  // without having to request it all the time.\n  var scrollHandler = function () {\n    self.scroll = _utils__WEBPACK_IMPORTED_MODULE_2__.getScroll();\n  };\n  _utils__WEBPACK_IMPORTED_MODULE_2__.bindEvt(window, 'scroll', function () {\n    _utils__WEBPACK_IMPORTED_MODULE_2__.throttle(scrollHandler);\n  });\n  return self.collections;\n}\nManager.prototype = new _super__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nManager.constructor = Manager;\nManager.prototype.prepareCollections = function () {\n  var self = this;\n  // Public API Preparation.\n  self.collections.create = self.create.bind(self);\n  // Listen to anything\n  self.collections.on = self.on.bind(self);\n  // Unbind general events\n  self.collections.off = self.off.bind(self);\n  // Destroy everything\n  self.collections.destroy = self.destroy.bind(self);\n  // Get any nipple\n  self.collections.get = function (id) {\n    var nipple;\n    // Use .every() to break the loop as soon as found.\n    self.collections.every(function (collection) {\n      nipple = collection.get(id);\n      return nipple ? false : true;\n    });\n    return nipple;\n  };\n};\nManager.prototype.create = function (options) {\n  return this.createCollection(options);\n};\n\n// Collection Factory\nManager.prototype.createCollection = function (options) {\n  var self = this;\n  var collection = new _collection__WEBPACK_IMPORTED_MODULE_0__[\"default\"](self, options);\n  self.bindCollection(collection);\n  self.collections.push(collection);\n  return collection;\n};\nManager.prototype.bindCollection = function (collection) {\n  var self = this;\n  var type;\n  // Bubble up identified events.\n  var handler = function (evt, data) {\n    // Identify the event type with the nipple's identifier.\n    type = evt.type + ' ' + data.id + ':' + evt.type;\n    self.trigger(type, data);\n  };\n\n  // When it gets destroyed we clean.\n  collection.on('destroyed', self.onDestroyed.bind(self));\n\n  // Other events that will get bubbled up.\n  collection.on('shown hidden rested dir plain', handler);\n  collection.on('dir:up dir:right dir:down dir:left', handler);\n  collection.on('plain:up plain:right plain:down plain:left', handler);\n};\nManager.prototype.bindDocument = function () {\n  var self = this;\n  // Bind only if not already binded\n  if (!self.binded) {\n    self.bindEvt(document, 'move').bindEvt(document, 'end');\n    self.binded = true;\n  }\n};\nManager.prototype.unbindDocument = function (force) {\n  var self = this;\n  // If there are no touch left\n  // unbind the document.\n  if (!Object.keys(self.ids).length || force === true) {\n    self.unbindEvt(document, 'move').unbindEvt(document, 'end');\n    self.binded = false;\n  }\n};\nManager.prototype.getIdentifier = function (evt) {\n  var id;\n  // If no event, simple increment\n  if (!evt) {\n    id = this.index;\n  } else {\n    // Extract identifier from event object.\n    // Unavailable in mouse events so replaced by latest increment.\n    id = evt.identifier === undefined ? evt.pointerId : evt.identifier;\n    if (id === undefined) {\n      id = this.latest || 0;\n    }\n  }\n  if (this.ids[id] === undefined) {\n    this.ids[id] = this.index;\n    this.index += 1;\n  }\n\n  // Keep the latest id used in case we're using an unidentified mouseEvent\n  this.latest = id;\n  return this.ids[id];\n};\nManager.prototype.removeIdentifier = function (identifier) {\n  var removed = {};\n  for (var id in this.ids) {\n    if (this.ids[id] === identifier) {\n      removed.id = id;\n      removed.identifier = this.ids[id];\n      delete this.ids[id];\n      break;\n    }\n  }\n  return removed;\n};\nManager.prototype.onmove = function (evt) {\n  var self = this;\n  self.onAny('move', evt);\n  return false;\n};\nManager.prototype.onend = function (evt) {\n  var self = this;\n  self.onAny('end', evt);\n  return false;\n};\nManager.prototype.oncancel = function (evt) {\n  var self = this;\n  self.onAny('end', evt);\n  return false;\n};\nManager.prototype.onAny = function (which, evt) {\n  var self = this;\n  var id;\n  var processFn = 'processOn' + which.charAt(0).toUpperCase() + which.slice(1);\n  evt = _utils__WEBPACK_IMPORTED_MODULE_2__.prepareEvent(evt);\n  var processColl = function (e, id, coll) {\n    if (coll.ids.indexOf(id) >= 0) {\n      coll[processFn](e);\n      // Mark the event to avoid cleaning it later.\n      e._found_ = true;\n    }\n  };\n  var processEvt = function (e) {\n    id = self.getIdentifier(e);\n    _utils__WEBPACK_IMPORTED_MODULE_2__.map(self.collections, processColl.bind(null, e, id));\n    // If the event isn't handled by any collection,\n    // we need to clean its identifier.\n    if (!e._found_) {\n      self.removeIdentifier(id);\n    }\n  };\n  _utils__WEBPACK_IMPORTED_MODULE_2__.map(evt, processEvt);\n  return false;\n};\n\n// Cleanly destroy the manager\nManager.prototype.destroy = function () {\n  var self = this;\n  self.unbindDocument(true);\n  self.ids = {};\n  self.index = 0;\n  self.collections.forEach(function (collection) {\n    collection.destroy();\n  });\n  self.off();\n};\n\n// When a collection gets destroyed\n// we clean behind.\nManager.prototype.onDestroyed = function (evt, coll) {\n  var self = this;\n  if (self.collections.indexOf(coll) < 0) {\n    return false;\n  }\n  self.collections.splice(self.collections.indexOf(coll), 1);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Manager);\n\n//# sourceURL=webpack://nipplejs/./src/manager.js?\n}");

/***/ }),

/***/ "./src/nipple.js":
/*!***********************!*\
  !*** ./src/nipple.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _super__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./super */ \"./src/super.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n\n///////////////////////\n///   THE NIPPLE    ///\n///////////////////////\n\nfunction Nipple(collection, options) {\n  this.identifier = options.identifier;\n  this.position = options.position;\n  this.frontPosition = options.frontPosition;\n  this.collection = collection;\n\n  // Defaults\n  this.defaults = {\n    size: 100,\n    threshold: 0.1,\n    color: 'white',\n    fadeTime: 250,\n    dataOnly: false,\n    restJoystick: true,\n    restOpacity: 0.5,\n    mode: 'dynamic',\n    zone: document.body,\n    lockX: false,\n    lockY: false,\n    shape: 'circle'\n  };\n  this.config(options);\n\n  // Overwrites\n  if (this.options.mode === 'dynamic') {\n    this.options.restOpacity = 0;\n  }\n  this.id = Nipple.id;\n  Nipple.id += 1;\n  this.buildEl().stylize();\n\n  // Nipple's API.\n  this.instance = {\n    el: this.ui.el,\n    on: this.on.bind(this),\n    off: this.off.bind(this),\n    show: this.show.bind(this),\n    hide: this.hide.bind(this),\n    add: this.addToDom.bind(this),\n    remove: this.removeFromDom.bind(this),\n    destroy: this.destroy.bind(this),\n    setPosition: this.setPosition.bind(this),\n    resetDirection: this.resetDirection.bind(this),\n    computeDirection: this.computeDirection.bind(this),\n    trigger: this.trigger.bind(this),\n    position: this.position,\n    frontPosition: this.frontPosition,\n    ui: this.ui,\n    identifier: this.identifier,\n    id: this.id,\n    options: this.options\n  };\n  return this.instance;\n}\nNipple.prototype = new _super__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nNipple.constructor = Nipple;\nNipple.id = 0;\n\n// Build the dom element of the Nipple instance.\nNipple.prototype.buildEl = function (options) {\n  this.ui = {};\n  if (this.options.dataOnly) {\n    return this;\n  }\n  this.ui.el = document.createElement('div');\n  this.ui.back = document.createElement('div');\n  this.ui.front = document.createElement('div');\n  this.ui.el.className = 'nipple collection_' + this.collection.id;\n  this.ui.back.className = 'back';\n  this.ui.front.className = 'front';\n  this.ui.el.setAttribute('id', 'nipple_' + this.collection.id + '_' + this.id);\n  this.ui.el.appendChild(this.ui.back);\n  this.ui.el.appendChild(this.ui.front);\n  return this;\n};\n\n// Apply CSS to the Nipple instance.\nNipple.prototype.stylize = function () {\n  if (this.options.dataOnly) {\n    return this;\n  }\n  var animTime = this.options.fadeTime + 'ms';\n  var borderStyle = _utils__WEBPACK_IMPORTED_MODULE_1__.getVendorStyle('borderRadius', '50%');\n  var transitStyle = _utils__WEBPACK_IMPORTED_MODULE_1__.getTransitionStyle('transition', 'opacity', animTime);\n  var styles = {};\n  styles.el = {\n    position: 'absolute',\n    opacity: this.options.restOpacity,\n    display: 'block',\n    'zIndex': 999\n  };\n  styles.back = {\n    position: 'absolute',\n    display: 'block',\n    width: this.options.size + 'px',\n    height: this.options.size + 'px',\n    left: 0,\n    marginLeft: -this.options.size / 2 + 'px',\n    marginTop: -this.options.size / 2 + 'px',\n    background: this.options.color,\n    'opacity': '.5'\n  };\n  styles.front = {\n    width: this.options.size / 2 + 'px',\n    height: this.options.size / 2 + 'px',\n    position: 'absolute',\n    display: 'block',\n    left: 0,\n    marginLeft: -this.options.size / 4 + 'px',\n    marginTop: -this.options.size / 4 + 'px',\n    background: this.options.color,\n    'opacity': '.5',\n    transform: 'translate(0px, 0px)'\n  };\n  _utils__WEBPACK_IMPORTED_MODULE_1__.extend(styles.el, transitStyle);\n  if (this.options.shape === 'circle') {\n    _utils__WEBPACK_IMPORTED_MODULE_1__.extend(styles.back, borderStyle);\n  }\n  _utils__WEBPACK_IMPORTED_MODULE_1__.extend(styles.front, borderStyle);\n  this.applyStyles(styles);\n  return this;\n};\nNipple.prototype.applyStyles = function (styles) {\n  // Apply styles\n  for (var i in this.ui) {\n    if (this.ui.hasOwnProperty(i)) {\n      for (var j in styles[i]) {\n        this.ui[i].style[j] = styles[i][j];\n      }\n    }\n  }\n  return this;\n};\n\n// Inject the Nipple instance into DOM.\nNipple.prototype.addToDom = function () {\n  // We're not adding it if we're dataOnly or already in dom.\n  if (this.options.dataOnly || document.body.contains(this.ui.el)) {\n    return this;\n  }\n  this.options.zone.appendChild(this.ui.el);\n  return this;\n};\n\n// Remove the Nipple instance from DOM.\nNipple.prototype.removeFromDom = function () {\n  if (this.options.dataOnly || !document.body.contains(this.ui.el)) {\n    return this;\n  }\n  this.options.zone.removeChild(this.ui.el);\n  return this;\n};\n\n// Entirely destroy this nipple\nNipple.prototype.destroy = function () {\n  clearTimeout(this.removeTimeout);\n  clearTimeout(this.showTimeout);\n  clearTimeout(this.restTimeout);\n  this.trigger('destroyed', this.instance);\n  this.removeFromDom();\n  this.off();\n};\n\n// Fade in the Nipple instance.\nNipple.prototype.show = function (cb) {\n  var self = this;\n  if (self.options.dataOnly) {\n    return self;\n  }\n  clearTimeout(self.removeTimeout);\n  clearTimeout(self.showTimeout);\n  clearTimeout(self.restTimeout);\n  self.addToDom();\n  self.restCallback();\n  setTimeout(function () {\n    self.ui.el.style.opacity = 1;\n  }, 0);\n  self.showTimeout = setTimeout(function () {\n    self.trigger('shown', self.instance);\n    if (typeof cb === 'function') {\n      cb.call(this);\n    }\n  }, self.options.fadeTime);\n  return self;\n};\n\n// Fade out the Nipple instance.\nNipple.prototype.hide = function (cb) {\n  var self = this;\n  if (self.options.dataOnly) {\n    return self;\n  }\n  self.ui.el.style.opacity = self.options.restOpacity;\n  clearTimeout(self.removeTimeout);\n  clearTimeout(self.showTimeout);\n  clearTimeout(self.restTimeout);\n  self.removeTimeout = setTimeout(function () {\n    var display = self.options.mode === 'dynamic' ? 'none' : 'block';\n    self.ui.el.style.display = display;\n    if (typeof cb === 'function') {\n      cb.call(self);\n    }\n    self.trigger('hidden', self.instance);\n  }, self.options.fadeTime);\n  if (self.options.restJoystick) {\n    const rest = self.options.restJoystick;\n    const newPosition = {};\n    newPosition.x = rest === true || rest.x !== false ? 0 : self.instance.frontPosition.x;\n    newPosition.y = rest === true || rest.y !== false ? 0 : self.instance.frontPosition.y;\n    self.setPosition(cb, newPosition);\n  }\n  return self;\n};\n\n// Set the nipple to the specified position\nNipple.prototype.setPosition = function (cb, position) {\n  var self = this;\n  self.frontPosition = {\n    x: position.x,\n    y: position.y\n  };\n  var animTime = self.options.fadeTime + 'ms';\n  var transitStyle = {};\n  transitStyle.front = _utils__WEBPACK_IMPORTED_MODULE_1__.getTransitionStyle('transition', ['transform'], animTime);\n  var styles = {\n    front: {}\n  };\n  styles.front = {\n    transform: 'translate(' + self.frontPosition.x + 'px,' + self.frontPosition.y + 'px)'\n  };\n  self.applyStyles(transitStyle);\n  self.applyStyles(styles);\n  self.restTimeout = setTimeout(function () {\n    if (typeof cb === 'function') {\n      cb.call(self);\n    }\n    self.restCallback();\n  }, self.options.fadeTime);\n};\nNipple.prototype.restCallback = function () {\n  var self = this;\n  var transitStyle = {};\n  transitStyle.front = _utils__WEBPACK_IMPORTED_MODULE_1__.getTransitionStyle('transition', 'none', '');\n  self.applyStyles(transitStyle);\n  self.trigger('rested', self.instance);\n};\nNipple.prototype.resetDirection = function () {\n  // Fully rebuild the object to let the iteration possible.\n  this.direction = {\n    x: false,\n    y: false,\n    angle: false\n  };\n};\nNipple.prototype.computeDirection = function (obj) {\n  var rAngle = obj.angle.radian;\n  var angle45 = Math.PI / 4;\n  var angle90 = Math.PI / 2;\n  var direction, directionX, directionY;\n\n  // Angular direction\n  //     \\  UP /\n  //      \\   /\n  // LEFT       RIGHT\n  //      /   \\\n  //     /DOWN \\\n  //\n  if (rAngle > angle45 && rAngle < angle45 * 3 && !obj.lockX) {\n    direction = 'up';\n  } else if (rAngle > -angle45 && rAngle <= angle45 && !obj.lockY) {\n    direction = 'left';\n  } else if (rAngle > -angle45 * 3 && rAngle <= -angle45 && !obj.lockX) {\n    direction = 'down';\n  } else if (!obj.lockY) {\n    direction = 'right';\n  }\n\n  // Plain direction\n  //    UP                 |\n  // _______               | RIGHT\n  //                  LEFT |\n  //   DOWN                |\n  if (!obj.lockY) {\n    if (rAngle > -angle90 && rAngle < angle90) {\n      directionX = 'left';\n    } else {\n      directionX = 'right';\n    }\n  }\n  if (!obj.lockX) {\n    if (rAngle > 0) {\n      directionY = 'up';\n    } else {\n      directionY = 'down';\n    }\n  }\n  if (obj.force > this.options.threshold) {\n    var oldDirection = {};\n    var i;\n    for (i in this.direction) {\n      if (this.direction.hasOwnProperty(i)) {\n        oldDirection[i] = this.direction[i];\n      }\n    }\n    var same = {};\n    this.direction = {\n      x: directionX,\n      y: directionY,\n      angle: direction\n    };\n    obj.direction = this.direction;\n    for (i in oldDirection) {\n      if (oldDirection[i] === this.direction[i]) {\n        same[i] = true;\n      }\n    }\n\n    // If all 3 directions are the same, we don't trigger anything.\n    if (same.x && same.y && same.angle) {\n      return obj;\n    }\n    if (!same.x || !same.y) {\n      this.trigger('plain', obj);\n    }\n    if (!same.x) {\n      this.trigger('plain:' + directionX, obj);\n    }\n    if (!same.y) {\n      this.trigger('plain:' + directionY, obj);\n    }\n    if (!same.angle) {\n      this.trigger('dir dir:' + direction, obj);\n    }\n  } else {\n    this.resetDirection();\n  }\n  return obj;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Nipple);\n\n//# sourceURL=webpack://nipplejs/./src/nipple.js?\n}");

/***/ }),

/***/ "./src/super.js":
/*!**********************!*\
  !*** ./src/super.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n///////////////////////\n///   SUPER CLASS   ///\n///////////////////////\n\n\n// Constants\nvar isTouch = !!('ontouchstart' in window);\nvar isPointer = window.PointerEvent ? true : false;\nvar isMSPointer = window.MSPointerEvent ? true : false;\nvar events = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    end: 'touchend, touchcancel'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    end: 'mouseup'\n  },\n  pointer: {\n    start: 'pointerdown',\n    move: 'pointermove',\n    end: 'pointerup, pointercancel'\n  },\n  MSPointer: {\n    start: 'MSPointerDown',\n    move: 'MSPointerMove',\n    end: 'MSPointerUp'\n  }\n};\nvar toBind;\nvar secondBind = {};\nif (isPointer) {\n  toBind = events.pointer;\n} else if (isMSPointer) {\n  toBind = events.MSPointer;\n} else if (isTouch) {\n  toBind = events.touch;\n  secondBind = events.mouse;\n} else {\n  toBind = events.mouse;\n}\nfunction Super() {}\n\n// Basic event system.\nSuper.prototype.on = function (arg, cb) {\n  var self = this;\n  var types = arg.split(/[ ,]+/g);\n  var type;\n  self._handlers_ = self._handlers_ || {};\n  for (var i = 0; i < types.length; i += 1) {\n    type = types[i];\n    self._handlers_[type] = self._handlers_[type] || [];\n    self._handlers_[type].push(cb);\n  }\n  return self;\n};\nSuper.prototype.off = function (type, cb) {\n  var self = this;\n  self._handlers_ = self._handlers_ || {};\n  if (type === undefined) {\n    self._handlers_ = {};\n  } else if (cb === undefined) {\n    self._handlers_[type] = null;\n  } else if (self._handlers_[type] && self._handlers_[type].indexOf(cb) >= 0) {\n    self._handlers_[type].splice(self._handlers_[type].indexOf(cb), 1);\n  }\n  return self;\n};\nSuper.prototype.trigger = function (arg, data) {\n  var self = this;\n  var types = arg.split(/[ ,]+/g);\n  var type;\n  self._handlers_ = self._handlers_ || {};\n  for (var i = 0; i < types.length; i += 1) {\n    type = types[i];\n    if (self._handlers_[type] && self._handlers_[type].length) {\n      self._handlers_[type].forEach(function (handler) {\n        handler.call(self, {\n          type: type,\n          target: self\n        }, data);\n      });\n    }\n  }\n};\n\n// Configuration\nSuper.prototype.config = function (options) {\n  var self = this;\n  self.options = self.defaults || {};\n  if (options) {\n    self.options = _utils__WEBPACK_IMPORTED_MODULE_0__.safeExtend(self.options, options);\n  }\n};\n\n// Bind internal events.\nSuper.prototype.bindEvt = function (el, type) {\n  var self = this;\n  self._domHandlers_ = self._domHandlers_ || {};\n  self._domHandlers_[type] = function () {\n    if (typeof self['on' + type] === 'function') {\n      self['on' + type].apply(self, arguments);\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn('[WARNING] : Missing \"on' + type + '\" handler.');\n    }\n  };\n  _utils__WEBPACK_IMPORTED_MODULE_0__.bindEvt(el, toBind[type], self._domHandlers_[type]);\n  if (secondBind[type]) {\n    // Support for both touch and mouse at the same time.\n    _utils__WEBPACK_IMPORTED_MODULE_0__.bindEvt(el, secondBind[type], self._domHandlers_[type]);\n  }\n  return self;\n};\n\n// Unbind dom events.\nSuper.prototype.unbindEvt = function (el, type) {\n  var self = this;\n  self._domHandlers_ = self._domHandlers_ || {};\n  _utils__WEBPACK_IMPORTED_MODULE_0__.unbindEvt(el, toBind[type], self._domHandlers_[type]);\n  if (secondBind[type]) {\n    // Support for both touch and mouse at the same time.\n    _utils__WEBPACK_IMPORTED_MODULE_0__.unbindEvt(el, secondBind[type], self._domHandlers_[type]);\n  }\n  delete self._domHandlers_[type];\n  return this;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Super);\n\n//# sourceURL=webpack://nipplejs/./src/super.js?\n}");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   angle: () => (/* binding */ angle),\n/* harmony export */   applyPosition: () => (/* binding */ applyPosition),\n/* harmony export */   bindEvt: () => (/* binding */ bindEvt),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   configStylePropertyObject: () => (/* binding */ configStylePropertyObject),\n/* harmony export */   degrees: () => (/* binding */ degrees),\n/* harmony export */   distance: () => (/* binding */ distance),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   findCoord: () => (/* binding */ findCoord),\n/* harmony export */   getScroll: () => (/* binding */ getScroll),\n/* harmony export */   getTransitionStyle: () => (/* binding */ getTransitionStyle),\n/* harmony export */   getVendorStyle: () => (/* binding */ getVendorStyle),\n/* harmony export */   isPressed: () => (/* binding */ isPressed),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   prepareEvent: () => (/* binding */ prepareEvent),\n/* harmony export */   radians: () => (/* binding */ radians),\n/* harmony export */   safeExtend: () => (/* binding */ safeExtend),\n/* harmony export */   throttle: () => (/* binding */ throttle),\n/* harmony export */   trigger: () => (/* binding */ trigger),\n/* harmony export */   unbindEvt: () => (/* binding */ unbindEvt)\n/* harmony export */ });\n/* harmony import */ var meta3d_utils_src_LandscapeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! meta3d-utils/src/LandscapeUtils */ \"../meta3d-utils/src/LandscapeUtils.js\");\n///////////////////////\n///      UTILS      ///\n///////////////////////\n\n\nconst distance = (p1, p2) => {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\nconst angle = (p1, p2) => {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  return degrees(Math.atan2(dy, dx));\n};\nconst findCoord = (p, d, a) => {\n  const b = {\n    x: 0,\n    y: 0\n  };\n  a = radians(a);\n  b.x = p.x - d * Math.cos(a);\n  b.y = p.y - d * Math.sin(a);\n  return b;\n};\nconst radians = a => {\n  return a * (Math.PI / 180);\n};\nconst degrees = a => {\n  return a * (180 / Math.PI);\n};\nconst isPressed = evt => {\n  if (isNaN(evt.buttons)) {\n    return evt.pressure !== 0;\n  }\n  return evt.buttons !== 0;\n};\nconst timers = new Map();\nconst throttle = cb => {\n  if (timers.has(cb)) {\n    clearTimeout(timers.get(cb));\n  }\n  timers.set(cb, setTimeout(cb, 100));\n};\nconst bindEvt = (el, arg, handler) => {\n  const types = arg.split(/[ ,]+/g);\n  let type;\n  for (let i = 0; i < types.length; i += 1) {\n    type = types[i];\n    if (el.addEventListener) {\n      el.addEventListener(type, handler, false);\n    } else if (el.attachEvent) {\n      el.attachEvent(type, handler);\n    }\n  }\n};\nconst unbindEvt = (el, arg, handler) => {\n  const types = arg.split(/[ ,]+/g);\n  let type;\n  for (let i = 0; i < types.length; i += 1) {\n    type = types[i];\n    if (el.removeEventListener) {\n      el.removeEventListener(type, handler);\n    } else if (el.detachEvent) {\n      el.detachEvent(type, handler);\n    }\n  }\n};\nconst trigger = (el, type, data) => {\n  const evt = new CustomEvent(type, data);\n  el.dispatchEvent(evt);\n};\nconst prepareEvent = evt => {\n  evt.preventDefault();\n  return evt.type.match(/^touch/) ? evt.changedTouches : evt;\n};\nconst getScroll = () => {\n  const x = window.pageXOffset !== undefined ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\n  const y = window.pageYOffset !== undefined ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n\n  /*!edit by meta3d */\n  // return {\n  //     x: x,\n  //     y: y\n  // };\n  return {\n    // x: LandscapeUtils.getScrollLeft(x, y),\n    // y: LandscapeUtils.getScrollTop(x, y)\n    x: 0,\n    y: 0\n  };\n};\nconst applyPosition = (el, pos) => {\n  if (pos.top || pos.right || pos.bottom || pos.left) {\n    el.style.top = pos.top;\n    el.style.right = pos.right;\n    el.style.bottom = pos.bottom;\n    el.style.left = pos.left;\n  } else {\n    el.style.left = pos.x + 'px';\n    el.style.top = pos.y + 'px';\n  }\n};\nconst getTransitionStyle = (property, values, time) => {\n  const obj = configStylePropertyObject(property);\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (typeof values === 'string') {\n        obj[i] = values + ' ' + time;\n      } else {\n        let st = '';\n        for (let j = 0, max = values.length; j < max; j += 1) {\n          st += values[j] + ' ' + time + ', ';\n        }\n        obj[i] = st.slice(0, -2);\n      }\n    }\n  }\n  return obj;\n};\nconst getVendorStyle = (property, value) => {\n  const obj = configStylePropertyObject(property);\n  for (let i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      obj[i] = value;\n    }\n  }\n  return obj;\n};\nconst configStylePropertyObject = prop => {\n  const obj = {};\n  obj[prop] = '';\n  const vendors = ['webkit', 'Moz', 'o'];\n  vendors.forEach(function (vendor) {\n    obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = '';\n  });\n  return obj;\n};\nconst extend = (objA, objB) => {\n  for (let i in objB) {\n    if (objB.hasOwnProperty(i)) {\n      objA[i] = objB[i];\n    }\n  }\n  return objA;\n};\n\n// Overwrite only what's already present\nconst safeExtend = (objA, objB) => {\n  const obj = {};\n  for (let i in objA) {\n    if (objA.hasOwnProperty(i) && objB.hasOwnProperty(i)) {\n      obj[i] = objB[i];\n    } else if (objA.hasOwnProperty(i)) {\n      obj[i] = objA[i];\n    }\n  }\n  return obj;\n};\n\n// Map for array or unique item.\nconst map = (ar, fn) => {\n  if (ar.length) {\n    for (let i = 0, max = ar.length; i < max; i += 1) {\n      fn(ar[i]);\n    }\n  } else {\n    fn(ar);\n  }\n};\n\n// Clamp position within the range\nconst clamp = (pos, nipplePos, size) => ({\n  //                          left-clamping        right-clamping\n  x: Math.min(Math.max(pos.x, nipplePos.x - size), nipplePos.x + size),\n  //                          top-clamping         bottom-clamping\n  y: Math.min(Math.max(pos.y, nipplePos.y - size), nipplePos.y + size)\n});\n\n//# sourceURL=webpack://nipplejs/./src/utils.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});